# AUTOGENERATED! DO NOT EDIT! File to edit: src/data_scrambler.ipynb (unless otherwise specified).

__all__ = ['DataScrambler']

# Cell
from .data import Data
from typing import List
import random

# Cell
class DataScrambler:
    @staticmethod
    def scramble_data(original: Data, conf: List['Configuration']) -> Data:
        atts = original.get_attributes()
        inst = []
        name = original.get_name() + '_scrambled'

        # create random for different configurations
        idxs_for_scrambling = {}
        for c in conf:
            idxs_for_scrambling[c] = DataScrambler.get_indices(
                int(c.to_scramble * len(original.get_instances())), len(original.get_instances()))

        instance_idx = 0
        for i in original.get_instances():
            new_instance = {'readings': {}}
            scrambled = []
            for c in conf:
                if instance_idx in idxs_for_scrambling[c]:
                    to_scramble = i['readings'][c.att_name]
                    scrambled_readings = []

                    # scramble, add to scrambled
                    best_val = to_scramble.get_most_probable()
                    scrambled_readings.append({'name': best_val['name'], 
                                               'confidence': best_val['confidence'] - c.mistake_epsilon, 
                                               'importances': {'Value':1}})
                    to_be_selected = []
                    for v in to_scramble['values']:
                        if v == best_val:
                            continue
                        if c.uniform:
                            scrambled_readings.append({'name': v['name'], 
                                                       'confidence': v['confidence'] + c.mistake_epsilon/(len(to_scramble['values']) - 1), 
                                                       'importances': {'Value':1}})
                        else:
                            to_be_selected.append(v)

                    if to_be_selected:
                        rand = random.randint(0, len(to_be_selected) - 1)
                        winner = to_be_selected[rand]
                        scrambled_readings.append({'name': winner['name'], 
                                                   'confidence': winner['confidence'] + c.mistake_epsilon, 
                                                   'importances': {'Value': 1}})
                        to_be_selected.remove(winner)

                    scrambled_readings += to_be_selected
                    index = 0
                    if len(scrambled_readings) > 1:
                        confidence = [value['confidence'] for value in scrambled_readings]
                        highest_conf = max(confidence)
                        index = confidence.index(highest_conf)
                    # now, we have complete reading in scrambled reading, add it to scrambled
                    scrambled.append({'base_att': original['readings'][c.att_name], 
                                      'values': scrambled_readings, 
                                      'most_probable': scrambled_readings[index]})

            # add scrambled and not scrambled to new instance - remember to keep the order of the original data
            for orig_reading in i['readings']:
                # find in scrambled
                was_scrambled = False
                for scr_reading in scrambled:
                    if scr_reading['base_att']['name'] == orig_reading['base_att']['name']:
                        new_instance['readings'][scr_reading['base_att']['name']] = scr_reading
                        was_scrambled = True
                        break
                if not was_scrambled:
                    new_instance['readings'][orig_reading['base_att']['name']] = orig_reading

            # add instance
            inst.append(new_instance)
            instance_idx += 1

        return Data(name, atts, inst)

    @staticmethod
    def get_indices(number: int, length: int) -> List[int]:
        indices = [i for i in range(length)]
        random.shuffle(indices)
        return indices[:number]

    class Configuration:
        def __init__(self, att_name: str, to_scramble: float, mistake_epsilon: float, uniform: bool):
            """
            Data scrambler configuration.

            Parameters
            ----------
            att_name : str
                Attribute name which values has to be made uncertain.
            to_scramble : float
                How much data (0-1) has to be scrambled.
            mistake_epsilon : float
                By what factor the data have to be scrambled.
                In other words, how much certainty has to be subtracted from the real
                value and assigned to other values.
            uniform : bool
                Does the probability have to be split between other values uniformly,
                or should one of the value be picked  randomly as 'favorable mistake'.
            """
            self.att_name = att_name
            self.to_scramble = to_scramble
            self.mistake_epsilon = mistake_epsilon
            self.uniform = uniform
