# AUTOGENERATED! DO NOT EDIT! File to edit: src/tree.ipynb (unless otherwise specified).

__all__ = ['Tree']

# Cell
from typing import List, Dict
from .tree_node import TreeNode
from .att_stats import AttStats
from .attribute import Attribute
from collections import defaultdict
import re
import pandas as pd
import os
import numpy as np
import seaborn as sns
from matplotlib import pyplot as plt

# Cell
class Tree:
    def __init__(self, root: TreeNode):
        self.root = root

    def get_root(self) -> TreeNode:
        return self.root

    def predict(self, i: np.array, i_labels: list) -> AttStats:
        test_node = self.get_root()
        name_val_dict = {}
        for key, val in zip(i_labels, i):
            name_val_dict[key] = str(val)
        while not test_node.is_leaf():
            att_to_test = test_node.get_att()
            most_probable_name = name_val_dict[att_to_test]

            new_node = None
            for te in test_node.get_edges():
                if test_node.get_type() == Attribute.TYPE_NOMINAL:
                    if te.get_value()['name'] == most_probable_name:
                        new_node = te.get_child()
                        break
                elif test_node.get_type() == Attribute.TYPE_NUMERICAL:
                    tev = self.compile_expr(name_val_dict, te.get_value())                   
                    if eval(f"{most_probable_name}{tev}"):
                        new_node = te.get_child()
                        break

            if new_node:
                test_node = new_node
            else:
                break

        return test_node.get_stats()
    
    def compile_expr(self, name_val_dict, v):
        expr = v['name']
        for key in sorted(name_val_dict.keys(),key=len,reverse=True):
            expr = expr.replace(key, name_val_dict[key])
        return expr
    
    def justification_tree(self, i, i_labels) -> str:
        test_node = self.get_root()
        root_handle=test_node.copy()
        root_handle.set_edges([])
        temp_root = root_handle
        name_val_dict = {}
        for key, val in zip(i_labels, i):
            name_val_dict[key] = str(val)
        while not test_node.is_leaf():
            att_to_test = test_node.get_att()
            most_probable_name = name_val_dict[att_to_test]

            new_node = None
            for te in test_node.get_edges():
                if test_node.get_type() == Attribute.TYPE_NOMINAL:
                    if te.get_value()['name'] == {most_probable_name}:
                        new_node = te.get_child()
                        te_copy = te.copy()
                        temp_root.set_edges([te_copy])
                        temp_root = te_copy.get_child()
                        break
                elif test_node.get_type() == Attribute.TYPE_NUMERICAL:
                    tev = self.compile_expr(name_val_dict, te.get_value())              
                    if eval(f"{most_probable_name}{tev}"):
                        new_node = te.get_child()
                        te_copy = te.copy()
                        temp_root.set_edges([te_copy])
                        temp_root = te_copy.get_child()
                        break
                

            if new_node:
                test_node = new_node
            else:
                break

        return Tree(root=root_handle)

    def get_attributes(self) -> list:
        return self.fill_attributes(list(), self.root)

    def get_importances(self) -> str:
        imps = []
        atts = self.get_attributes()
        for a in atts:
            if a['name'] == self.get_class_attribute()['name']:
                break
            imps.append(str(a['info_gain']))
            print(a, a['info_gain'], "============================")

        return ','.join(imps)
    
    def to_HMR(self) -> str:
        pattern = r'\b[A-Za-z]+(?:[^a-zA-Z\s0-9]+[A-Za-z]+)*(?:\s[A-Za-z]+(?:[^a-zA-Z\s0-9]+[A-Za-z]+)*)*\b'
        
        result = "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% TYPES DEFINITIONS %%%%%%%%%%%%%%%%%%%%%%%%%%\n\n"

        #types are defined by atts domains
        atts = self.get_attributes()
        for att in atts:
            result += f"xtype [\n name: '{att['name']}', \n"
            if att['type'] == Attribute.TYPE_NOMINAL:
                result += f"base:symbolic,\n domain : ["
                domain_res = ""
                for v in att['domain']:
                    domain_res += f"{v},"

                result += domain_res.strip()[:-1].replace("[<>=]","")

            elif att['type'] == Attribute.TYPE_NUMERICAL:
                result += "base:numeric,\n" + "domain : ["
                result += "-100000 to 100000"

            result += "]].\n"

        result += "\n%%%%%%%%%%%%%%%%%%%%%%%%% ATTRIBUTES DEFINITIONS %%%%%%%%%%%%%%%%%%%%%%%%%%\n"
        for att in atts:
            result += f"xattr [ name: '{att['name']}',\n type:'{att['name']}',\n class:simple,\n comm:out ].\n"

        #tables and rules
        result +="\n%%%%%%%%%%%%%%%%%%%%%%%% TABLE SCHEMAS DEFINITIONS %%%%%%%%%%%%%%%%%%%%%%%%\n"

        result += " xschm tree : ["
        for att in atts:
            if not att['name'] == self.get_class_attribute()['name']:
                result += f"'{att['name']}',"

        result = f"{result.strip()[:-1]}]"
        result += f"==> ['{self.get_class_attribute()['name']}'].\n"

        #rules

        rules = self.get_rules()
        decision_att = self.get_class_attribute()['name']
        dec_att = self.get_class_attribute()
        cond_atts = {'name': None, 'domain': None, 'type': None, 'value_to_split_on': '', 'info_gain': 0.0}
        cond_atts_list = list(atts)
        for elem in cond_atts_list:
            if elem['name'] == dec_att['name']:
                cond_atts_list.remove(elem)

        for i, rule in enumerate(rules):
            result += f"xrule tree/{i}:\n["

            #conditions
            for att in atts:
                if att['name'] == self.get_class_attribute()['name']:
                    continue

                value = {'name': 'any', 'confidence': 1.0, 'importances': {'Value': 1.0}}

                found = False
                for c in rule:
                    if c.att_name == att['name']:
                        found=True
                        value = c.value
                        v_name = value['name']
                        all_names = set(re.findall(pattern, value['name']))
                        for name in all_names:
                            v_name = value['name'].replace(name, f"'{name}'")
                        result +=  f"'{att['name']}' {v_name.replace('>=',' gte ').replace('<',' lt ')}, "

                if not found:
                    result += f"'{att['name']}' eq any, "

            result = f"{result.strip()[:-1]}] ==> ["

            #decision

            confidence = 1
            for c in rule:
                confidence *= c.value['confidence']

            for c in rule:
                if c.att_name == decision_att:
                    ex = '\\['
                    result += f"'{decision_att}' set {c.value['name'].split(ex)[0]}"

            confidence = confidence * 10 / 10.0
            result += f"]. # {confidence}\n"

        result += "\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n"
        result += "% File generated by LUX \n"
        result += "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n"
        # result += "</table></xtt><callbacks/></hml>\n"
        return result
    
    def to_pseudocode(self, reduce=True, operators_mapping=None) -> str:
        result = ""
        if operators_mapping is None:
            operators_mapping = {'if':'IF',
                                 'then':'THEN',
                                 'and':'AND',
                                 'eq':'==',
                                 '<':'<', 
                                 '>=':'>=',
                                 'set':'='
                                }
            

        decision_att = self.get_class_attribute()['name']
        list_result = self.to_dict(reduce=reduce, operators_mapping=operators_mapping)
        result = ""
        for rule in list_result:
            result+=operators_mapping['if']+" "
            conditional_part=[]
            for k,v in rule['rule'].items():
                conditional_part.append(f'{k} '+f" {operators_mapping['and']} {k} ".join(v))
            result+=f" {operators_mapping['and']} ".join(conditional_part)
            ex = '\\['
            result += f" {operators_mapping['then']} {decision_att} {operators_mapping['set']} {rule['prediction']}"
            result += f" # {rule['confidence']}\n"

        return result

    def to_dict(self, reduce = True, operators_mapping=None) -> List[Dict]:
        result = []
        if operators_mapping is None:
            operators_mapping = {'if':'IF',
                                 'then':'THEN',
                                 'and':'AND',
                                 'eq':'==',
                                 '<':'<', 
                                 '>=':'>=',
                                 'set':'='
                                }
            

        #types are defined by atts domains
        atts = self.get_attributes()
        rules = self.get_rules()
        decision_att = self.get_class_attribute()['name']
        dec_att = self.get_class_attribute()
        #cond_atts = {'name': None, 'domain': None, 'type': None, 'value_to_split_on': '', 'info_gain': 0.0}
        cond_atts_list = list(atts)
        for elem in cond_atts_list:
            if elem['name'] == dec_att['name']:
                cond_atts_list.remove(elem)

        for rule in rules:
            conditions = []
            condition_values=[]
            #conditions
            for att in atts:
                if att['name'] == self.get_class_attribute()['name']:
                    continue

                value = {'name': 'any', 'confidence': 1.0, 'importances': {'Value': 1.0}}

                for c in rule:
                    if c.att_name == att['name']:
                        value = c.value
                        if att['type'] == Attribute.TYPE_NOMINAL:
                            condition_value = f"{operators_mapping['eq']} {value['name']}"
                        else:
                            condition_value = value['name'].replace('>=',f"{operators_mapping['>=']} ").replace('<',f"{operators_mapping['<']} ")
                        
                        condition_values.append(condition_value)
                        conditions.append(f"{att['name']}".strip())

            #decision

            confidence = 1
            for c in rule:
                confidence *= c.value['confidence']

            for c in rule:
                if c.att_name == decision_att:
                    ex = '\\['
                    prediction = c.value['name'].split(ex)[0]

            confidence = confidence * 10 / 10.0

            rule_dict_long = defaultdict(list)
            for k, v in zip(conditions, condition_values):
                rule_dict_long[k].append(v)
            
            if reduce: 
                rule_dict = {}
                for k,v in rule_dict_long.items():
                    rule_dict[k] = self.__reduce_condition(rule_dict_long[k], operators_mapping=operators_mapping)
            else:
                rule_dict = dict(rule_dict_long)
            
            result.append(dict({'rule':rule_dict, 'prediction':prediction, 'confidence':confidence}))


        return result
    
    def __reduce_condition(self, conditions: list, operators_mapping: dict) -> list:
        #only for numerical and non-linear split
        result = []
        lt = [c for c in conditions if operators_mapping['<'] in c]
        if len(lt) > 0:
            to_minimize = [float(re.sub(operators_mapping['<'],'',x)) for x in lt if  not re.search(r'\b[a-zA-Z_]\w*\b',x)]
            if len(to_minimize) > 0:
                lt_condition = min(to_minimize)
                result.append(f"{operators_mapping['<']}{lt_condition}")
            for lcd in [re.sub(operators_mapping['<'],'',x) for x in lt if  re.search(r'\b[a-zA-Z_]\w*\b',x)]:
                result.append(f"{operators_mapping['<']}{lcd}")

        gte = [c for c in conditions if operators_mapping['>='] in c]
        if len(gte) > 0:
            to_maximize = [float(re.sub(operators_mapping['>='],'',x)) for x in gte if  not re.search(r'\b[a-zA-Z_]\w*\b',x)]
            if len(to_maximize)>0:
                gte_condition = max(to_maximize)
                result.append(f"{operators_mapping['>=']}{gte_condition}")
            for gcd in [re.sub(operators_mapping['>='],'',x) for x in gte if  re.search(r'\b[a-zA-Z_]\w*\b',x)]:
                result.append(f"{operators_mapping['>=']}{gcd}")
        return result+[c for c in conditions if operators_mapping['eq'] in c]
    
    def save_dot(self, filename: str, fmt=None,  visual=False, background_data:pd.DataFrame=None, 
                instance2explain=None, counterfactual=None) -> None:
        f = open(filename, "w")
        if visual:
            if background_data is not None:
                if instance2explain is not None and not isinstance(instance2explain, pd.DataFrame):
                    instance2explain=pd.DataFrame(instance2explain)
                if counterfactual is not None and not isinstance(counterfactual, pd.DataFrame):
                    counterfactual=pd.DataFrame(counterfactual)
            f.write(self.to_dot_visual(parent=None, fmt=fmt, background_data=background_data,
                                      instance2explain=instance2explain, counterfactual=counterfactual))
        else:
            f.write(self.to_dot(parent=None,fmt=fmt))
        f.close()

    def get_class_attribute(self) -> Dict:
        temp  = self.root
        while not temp.is_leaf():
            temp = temp.get_edges()[0].get_child()

        result = {'name': temp.get_att(), 'domain': set(), 'type': None, 'value_to_split_on': '', 'info_gain': 0.0}
        for v in temp.get_stats().get_statistics():
            result['domain'].add(v['name'])

        return result

    def fill_rules(self, rules: list, current_rule: list, root: TreeNode) -> list:
        if not current_rule:
            current_rule = []

        att_name = root.get_att()
        if not root.is_leaf():
            for e in root.get_edges():
                new_rule = current_rule.copy()
                new_rule.append(self.Condition(att_name, e.get_value(), "eq"))
                self.fill_rules(rules, new_rule, e.get_child())

        else:
            final_rule = current_rule.copy()
            final_rule.append(self.Condition(att_name, root.get_stats().get_most_probable(), "set"))
            rules.append(final_rule)

        return rules

    def get_rules(self) -> list:
        return self.fill_rules([], None, self.get_root())

    def fill_attributes(self, result=None, root=None) -> list:
         if result != None and root != None:
            att_name = root.get_att()
            att = {'name': att_name, 'domain': set(), 'type': root.get_type(), 'value_to_split_on': '', 'info_gain': 0.0}
            att['info_gain'] = root.get_infogain()
            for val in result:
                if val['name'] == att['name']:
                    for tmp in result:
                        if tmp == att['name']:
                            att = tmp
                            break
                    break

            if not root.is_leaf():
                for  e in root.get_edges():
                    att['domain'].add(e.get_value()['name'])
                    self.fill_attributes(result, e.get_child())
                should_add = True
                for val in result:
                    if val['name'] == att['name']:
                        should_add = False
                if should_add:
                    result.append(att)
            else:
                for v in root.get_stats().get_statistics():
                    att['domain'].add(v['name'])

                should_add = True
                for val in result:
                    if val['name'] == att['name']:
                        should_add = False
                if should_add:
                    result.append(att)

            return result
         else:

            return self.fill_attributes(list(), root)

    def to_dot(self, parent=None, fmt=None) -> str:
        if parent:
            result = ""
            label = parent.get_att() + "\n"
            if parent.is_leaf():
                # Add classification info to leaves
                for v in parent.get_stats().get_statistics():
                    label += f"{v['name']}[{v['confidence']:{fmt}}]" + "\n"

            col = "red" if parent.is_leaf() else "black"
            result += f"{hash(parent)}[label=\" {label} \",shape=box, color={col}]"

            for te in parent.get_edges():
                if parent.get_type() == Attribute.TYPE_NUMERICAL and fmt is not None:
                    value = te.get_value()['name']
                    value=self.__format_expression(value,fmt)
                else:
                    value = value=te.get_value()['name']
                result += f"{hash(parent)}->{hash(te.get_child())}[label=\"{value}\n conf={round(te.get_value()['confidence'] * 100.0) / 100.0} \"]\n"
                result += self.to_dot(te.get_child(),fmt=fmt)

            return result

        else:
            result = "digraph mediationTree{\n"
            result += self.to_dot(self.root,fmt=fmt)

            return result+"\n}"
        
    @staticmethod    
    def __find_features(background_data, expr):
        features = sorted(background_data.columns,key=len,reverse=True)
        columns=[]
        for f in features:
            if f in expr:
                expr = expr.replace(f, "")
                columns+=[f]
        return columns
    
    def __format_expression(self,value,fmt):
        value_tr = value
        for f in [a['name'] for a in self.get_attributes()]:
            value_tr = re.sub(r'\b[a-zA-Z_]\w*\b','',value_tr)
        numbers = re.findall("[-]?[.]?[\d]+(?:,\d\d\d)*[\.]?\d*(?:[eE][-+]?\d+)?", value_tr)
        formatted = [("{value:"+fmt+"}").format(value=float(v)) for v in numbers]
        for k,v in zip(numbers, formatted):
            value = value.replace(k,v)
        return value

    def to_dot_visual(self, parent=None, background_data: pd.DataFrame=None, instance2explain=None, counterfactual=None, file_format='png', palette='Set2', fmt=None) -> str:
        path = '.'
        features=[]
        target_column = background_data.columns[-1]
        background_data[target_column] = background_data[target_column].astype(str)
        pattern = r'\b[A-Za-z]+(?:[^a-zA-Z\s0-9]+[A-Za-z]+)*(?:\s[A-Za-z]+(?:[^a-zA-Z\s0-9]+[A-Za-z]+)*)*\b'
        if not os.path.exists(path+'/imgs/'):
            os.makedirs(path+'/imgs/')
        if parent:
            result = ""
            col = "red" if parent.is_leaf() else "black"
            if parent.is_leaf():
                fig,ax=plt.subplots(figsize=(3,3))
                if instance2explain is not None:
                    instance2explain[target_column] = instance2explain[target_column].astype(str)
                    background_data = pd.concat((instance2explain,background_data))
                if counterfactual is not None:
                    counterfactual[target_column] = counterfactual[target_column].astype(str)
                    background_data = pd.concat((counterfactual,background_data))
                background_data[target_column] = background_data[target_column].astype(str)
                stats = background_data[[target_column]].value_counts().to_frame('samples').sort_index().reset_index()
                if len(stats) > 0:
                    sns.barplot(data = stats,
                            x=target_column,y='samples', alpha=0.7,palette=palette,hue=target_column,ax=ax)
                else:
                    sns.heatmap(pd.DataFrame([0]), cbar=False, ax=ax)
                    ax.set_facecolor('gray')
                    plt.text(0.5, 0.5, 'Phantom', ha='center', va='center', fontsize=20, color='white', weight='bold')

                if instance2explain is not None:
                    pos = stats[stats[target_column]==instance2explain[target_column].values[0]].index[0]
                    ax.plot(pos,1, 'or', markersize=8)
                if counterfactual is not None:
                    pos = stats[stats[target_column]==counterfactual[target_column].values[0]].index[0]
                    ax.plot(pos,1, 'ob', markersize=8)

                if len(stats) > 0:
                    for patch, label in zip(ax.patches, [f'{l:.2f}%' for l in list(
                            background_data[[target_column]].value_counts(normalize=True).sort_index() * 100)]):
                        ax.annotate(label,
                                    (patch.get_x() + patch.get_width() / 2., patch.get_height() / 2),
                                    ha='center', va='center')
                plt.savefig(f'{path}/imgs/{hash(parent)}.{file_format}', format=file_format,bbox_inches='tight')
                plt.close()
                result += f"{hash(parent)}[label=\"\",shape=box, color={col},image=\"{path}/imgs/{hash(parent)}.{file_format}\"]"

            has_plotted=False
            for te in parent.get_edges():
                if parent.get_type() == Attribute.TYPE_NUMERICAL:
                    op=''
                else:
                    op='=='
                
                all_names = set(re.findall(pattern, te.get_value()['name'].replace("and", "")))
                v = te.get_value()['name']
                for name in all_names:
                    new = '`' + name + '`'
                    v = v.replace(name, new)

                sibling_data = background_data.query(f"`{parent.get_att()}`" + f'{op}' + v)
                                                     
                if not has_plotted and not parent.is_leaf():
                    result += f"{hash(parent)}[label=\"\",shape=box, color={col}, image=\"{path}/imgs/{hash(parent)}.{file_format}\"]"
                    has_plotted = True
                    if re.search(r'\b[a-zA-Z_]\w*\b',te.get_value()['name']):
                        #it's and expression, and we need to visualize it as a plot of two features
                        plt.figure(figsize=(8,3))
                        features = Tree.__find_features(background_data,te.get_value()['name'])
                        grid=sns.scatterplot(data = background_data[features+[parent.get_att(),target_column]], x=features[0],y=parent.get_att(),
                                        hue=target_column,palette=palette,alpha=0.5)
                        if instance2explain is not None:
                            ax = grid.axes
                            ax.plot(instance2explain[features[0]],instance2explain[parent.get_att()], 'or', markersize=8)
                        if counterfactual is not None:
                            ax = grid.axes
                            ax.plot(counterfactual[features[0]],counterfactual[parent.get_att()], 'ob', markersize=8)
                        grid.axes.set_title(f"{parent.get_att()}",fontsize=20)
                        data = background_data.eval(re.sub("[<>=]","", v)).to_frame(parent.get_att())
                        data[features[0]] = background_data[features[0]]
                        sns.lineplot(data=data,x=features[0],y=parent.get_att(), linestyle='--',color='r')
                        plt.savefig(f'{path}/imgs/{hash(parent)}.{file_format}', format=file_format,bbox_inches='tight')
                        plt.close()
                    else:
                        grid=sns.displot(background_data, x=parent.get_att(),hue=target_column,kind='hist',fill=True,height=3,
                                         palette=palette,aspect=3,alpha=0.5)
                        ax = grid.axes[0][0]
                        ax.set_title(f"{parent.get_att()}",fontsize=20)
                        ax.axvline(float(re.sub("[<>=]","",te.get_value()['name'])),linestyle='--',color='r')
                        if instance2explain is not None:
                            ax.plot(instance2explain[parent.get_att()],1, 'or', markersize=8)
                        if counterfactual is not None:
                            ax.plot(counterfactual[parent.get_att()],1, 'ob', markersize=8)
                        plt.savefig(f'{path}/imgs/{hash(parent)}.{file_format}', format=file_format,bbox_inches='tight')
                        plt.close()
                if parent.get_type() == Attribute.TYPE_NUMERICAL and fmt is not None:
                    value = te.get_value()['name']
                    value=self.__format_expression(value,fmt)
                else:
                    value = te.get_value()['name']
                    
                result += f"{hash(parent)}->{hash(te.get_child())}[label=\"{value}\n conf={round(te.get_value()['confidence'] * 100.0) / 100.0} \"]\n"
                sibling_instance2explain=instance2explain
                sibling_counterfactual=counterfactual
                if instance2explain is not None:
                    if len(instance2explain.query(f"`{parent.get_att()}`"+f'{op}'+v)) == 0:
                        sibling_instance2explain=None 
                if counterfactual is not None:
                    if len(counterfactual.query(f"`{parent.get_att()}`"+f'{op}'+v)) == 0:
                        sibling_counterfactual=None 
                result += self.to_dot_visual(parent=te.get_child(),background_data=sibling_data,
                                            instance2explain=sibling_instance2explain, 
                                            counterfactual=sibling_counterfactual,palette=palette,fmt=fmt)

            return result

        else:

            palette = dict(zip(background_data[target_column].unique(),sns.color_palette(palette,background_data[target_column].nunique())))

            result = "digraph mediationTree{\n"
            result += self.to_dot_visual(parent=self.root, background_data=background_data,instance2explain=instance2explain, counterfactual=counterfactual, palette=palette,fmt=fmt)

            return result+"\n}"


    def __str__(self, lvl=None, val=None, node=None):
        if lvl != None and val and node:
            result = "|"
            res = "-------" * lvl
            result = result + res
            result += f"is  {val}"
            if node.is_leaf():
                result += f" then {node.get_att()} = {node.get_stats()} \n"
            else:
                result += f"then if {node.get_att()} (play= {node.get_stats()} )\n"
            lvl += 1
            for te in node.get_edges():
                result += self.__str__(lvl, te.get_value(),te.get_child())
        else:
            result = f"if {self.root.get_att()} (play= {self.root.get_stats()})\n"
            for te in self.root.get_edges():
                result += self.__str__(0, te.get_value(), te.get_child())

        return result



    class Condition:
        def __init__(self, att_name: str, value: Dict, op='eq'):
            self.att_name = att_name
            self.value = value
            self.op = op