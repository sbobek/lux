# AUTOGENERATED! DO NOT EDIT! File to edit: src/tree.ipynb (unless otherwise specified).

__all__ = ['Tree']

# Cell
from typing import Dict
from .tree_node import TreeNode
from .att_stats import AttStats
from .attribute import Attribute
from collections import defaultdict
import re
import pandas as pd
import os
import seaborn as sns
from matplotlib import pyplot as plt

# Cell
class Tree:
    def __init__(self, root: TreeNode):
        self.root = root

    def get_root(self) -> TreeNode:
        return self.root

    def predict(self, i: Dict) -> AttStats:
        test_node = self.get_root()
        while not test_node.is_leaf():
            att_to_test = test_node.get_att()
            r = i['readings'][att_to_test]
            most_probable = r['most_probable']

            new_node = None
            for te in test_node.get_edges():
                if test_node.get_type() == Attribute.TYPE_NOMINAL:
                    if te.get_value()['name'] == most_probable['name']:
                        new_node = te.get_child()
                        break
                elif test_node.get_type() == Attribute.TYPE_NUMERICAL:
                    tev = self.compile_expr(i, te.get_value())                   
                    if eval(f"{most_probable['name']}{tev}"):
                        new_node = te.get_child()
                        break

            if new_node:
                test_node = new_node
            else:
                break

        return test_node.get_stats()
    
    def compile_expr(self, i, v):
        readings = i['readings']
        expr = v['name']
        for key in sorted(readings.keys(),key=len,reverse=True):
            expr = expr.replace(key, readings[key]['most_probable']['name'])
        return expr
    
    def justification_tree(self, i: Dict) -> str:
        test_node = self.get_root()
        root_handle=test_node.copy()
        root_handle.set_edges([])
        temp_root = root_handle
        while not test_node.is_leaf():
            att_to_test = test_node.get_att()
            r = i['readings'][att_to_test]
            most_probable = r['most_probable']

            new_node = None
            for te in test_node.get_edges():
                if test_node.get_type() == Attribute.TYPE_NOMINAL:
                    if eval(f"{te.get_value()['name']} == {most_probable['name']}"):
                        new_node = te.get_child()
                        te_copy = te.copy()
                        temp_root.set_edges([te_copy])
                        temp_root = te_copy.get_child()
                        break
                elif test_node.get_type() == Attribute.TYPE_NUMERICAL:
                    tev = self.compile_expr(i, te.get_value())                 
                    if eval(f"{most_probable['name']}{tev}"):
                        new_node = te.get_child()
                        te_copy = te.copy()
                        temp_root.set_edges([te_copy])
                        temp_root = te_copy.get_child()
                        break
                

            if new_node:
                test_node = new_node
            else:
                break

        return Tree(root=root_handle)

    def error(self, i: Dict) -> bool:
        result = self.predict(i)

        return result['most_probable']['name'] == i['readings'][-1]['most_probable']['name']

    def get_attributes(self) -> list:
        return self.fill_attributes(list(), self.root)

    def get_importances(self) -> str:
        imps = []
        atts = self.get_attributes()
        for a in atts:
            if a['name'] == self.get_class_attribute()['name']:
                break
            imps.append(str(a['info_gain']))
            print(a, a['info_gain'], "============================")

        return ','.join(imps)
    
    def to_HMR(self) -> str:
        result = "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% TYPES DEFINITIONS %%%%%%%%%%%%%%%%%%%%%%%%%%\n\n"

        #types are defined by atts domains
        atts = self.get_attributes()
        for att in atts:
            result += f"xtype [\n name: {att['name']}, \n"
            if att['type'] == Attribute.TYPE_NOMINAL:
                result += f"base:symbolic,\n domain : ["
                domain_res = ""
                for v in att['domain']:
                    domain_res += f"{v},"

                result += domain_res.strip()[:-1].replace("[<>=]","")

            elif att['type'] == Attribute.TYPE_NUMERICAL:
                result += "base:numeric,\n" + "domain : ["
                result += "-100000 to 100000"

            result += "]].\n"

        result += "\n%%%%%%%%%%%%%%%%%%%%%%%%% ATTRIBUTES DEFINITIONS %%%%%%%%%%%%%%%%%%%%%%%%%%\n"
        for att in atts:
            result += f"xattr [ name: {att['name']},\n type:{att['type']},\n class:simple,\n comm:out ].\n"

        #tables and rules
        result +="\n%%%%%%%%%%%%%%%%%%%%%%%% TABLE SCHEMAS DEFINITIONS %%%%%%%%%%%%%%%%%%%%%%%%\n"

        result += " xschm tree : ["
        for att in atts:
            if not att['name'] == self.get_class_attribute()['name']:
                result += f"{att['name']},"

        result = f"{result.strip()[:-1]}]"
        result += f"==> [{self.get_class_attribute()['name']}].\n"

        #rules

        rules = self.get_rules()
        decision_att = self.get_class_attribute()['name']
        dec_att = self.get_class_attribute()
        cond_atts = {'name': None, 'domain': None, 'type': None, 'value_to_split_on': '', 'info_gain': 0.0}
        cond_atts_list = list(atts)
        for elem in cond_atts_list:
            if elem['name'] == dec_att['name']:
                cond_atts_list.remove(elem)

        for i, rule in enumerate(rules):
            result += f"xrule tree/{i}:\n["

            #conditions
            for att in atts:
                if att['name'] == self.get_class_attribute()['name']:
                    continue

                value = {'name': 'any', 'confidence': 1.0, 'importances': {'Value': 1.0}}

                found = False
                for c in rule:
                    if c.att_name == att['name']:
                        found=True
                        value = c.value
                        result +=  f"{att['name']} {value['name'].replace('>=',' gte ').replace('<',' lt ')}, "

                if not found:
                    result += f"{att['name']} eq any, "

            result = f"{result.strip()[:-1]}] ==> ["

            #decision

            confidence = 1
            for c in rule:
                confidence *= c.value['confidence']

            for c in rule:
                if c.att_name == decision_att:
                    ex = '\\['
                    result += f"{decision_att} set {c.value['name'].split(ex)[0]}"

            confidence = confidence * 10 / 10.0
            result += f"]. # {confidence}\n"


        # result += "</table></xtt><callbacks/></hml>\n"
        return result
    
    def to_pseudocode(self, reduce=True, operators_mapping=None) -> str:
        result = ""
        if operators_mapping is None:
            operators_mapping = {'if':'IF',
                                 'then':'THEN',
                                 'and':'AND',
                                 'eq':'==',
                                 '<':'<', 
                                 '>=':'>=',
                                 'set':'='
                                }
            

        decision_att = self.get_class_attribute()['name']
        list_result = self.to_dict(reduce=reduce, operators_mapping=operators_mapping)
        result = ""
        for rule in list_result:
            result+=operators_mapping['if']+" "
            conditional_part=[]
            for k,v in rule['rule'].items():
                conditional_part.append(f'{k} '+f" {operators_mapping['and']} {k} ".join(v))
            result+=f" {operators_mapping['and']} ".join(conditional_part)
            ex = '\\['
            result += f" {operators_mapping['then']} {decision_att} {operators_mapping['set']} {rule['prediction']}"
            result += f" # {rule['confidence']}\n"

        return result

    def to_dict(self, reduce = True, operators_mapping=None) -> str:
        result = []
        if operators_mapping is None:
            operators_mapping = {'if':'IF',
                                 'then':'THEN',
                                 'and':'AND',
                                 'eq':'==',
                                 '<':'<', 
                                 '>=':'>=',
                                 'set':'='
                                }
            

        #types are defined by atts domains
        atts = self.get_attributes()
        rules = self.get_rules()
        decision_att = self.get_class_attribute()['name']
        dec_att = self.get_class_attribute()
        cond_atts = {'name': None, 'domain': None, 'type': None, 'value_to_split_on': '', 'info_gain': 0.0}
        cond_atts_list = list(atts)
        for elem in cond_atts_list:
            if elem['name'] == dec_att['name']:
                cond_atts_list.remove(elem)

        for i, rule in enumerate(rules):
            conditions = []
            condition_values=[]
            #conditions
            for att in atts:
                if att['name'] == self.get_class_attribute()['name']:
                    continue

                value = {'name': 'any', 'confidence': 1.0, 'importances': {'Value': 1.0}}

                for c in rule:
                    if c.att_name == att['name']:
                        value = c.value
                        if att['type'] == Attribute.TYPE_NOMINAL:
                            condition_value = f"{operators_mapping['eq']} {value['name']}"
                        else:
                            condition_value = value['name'].replace('>=',f"{operators_mapping['>=']} ").replace('<',f"{operators_mapping['<']} ")
                        
                        condition_values.append(condition_value)
                        conditions.append(f"{att['name']}".strip())

            #decision

            confidence = 1
            for c in rule:
                confidence *= c.value['confidence']

            for c in rule:
                if c.att_name == decision_att:
                    ex = '\\['
                    prediction = c.value['name'].split(ex)[0]

            confidence = confidence * 10 / 10.0

            rule_dict_long = defaultdict(list)
            for k, v in zip(conditions, condition_values):
                rule_dict_long[k].append(v)
            
            if reduce: 
                rule_dict = {}
                for k,v in rule_dict_long.items():
                    rule_dict[k] = self.__reduce_condition(rule_dict_long[k], operators_mapping=operators_mapping)
            else:
                rule_dict = dict(rule_dict_long)
            
            result.append(dict({'rule':rule_dict, 'prediction':prediction, 'confidence':confidence}))


        return result
    
    def __reduce_condition(self, conditions: list, operators_mapping: dict) -> list:
        #only for numerical and non-linear split
        result = []
        lt = [c for c in conditions if operators_mapping['<'] in c]
        if len(lt) > 0:
            to_minimize = [float(re.sub(operators_mapping['<'],'',x)) for x in lt if  not re.search(r'\b[a-zA-Z_]\w*\b',x)]
            if len(to_minimize) > 0:
                lt_condition = min(to_minimize)
                result.append(f"{operators_mapping['<']}{lt_condition}")
            for lcd in [re.sub(operators_mapping['<'],'',x) for x in lt if  re.search(r'\b[a-zA-Z_]\w*\b',x)]:
                result.append(f"{operators_mapping['<']}{lcd}")

        gte = [c for c in conditions if operators_mapping['>='] in c]
        if len(gte) > 0:
            to_maximize = [float(re.sub(operators_mapping['>='],'',x)) for x in gte if  not re.search(r'\b[a-zA-Z_]\w*\b',x)]
            if len(to_maximize)>0:
                gte_condition = max(to_maximize)
                result.append(f"{operators_mapping['>=']}{gte_condition}")
            for gcd in [re.sub(operators_mapping['>='],'',x) for x in gte if  re.search(r'\b[a-zA-Z_]\w*\b',x)]:
                result.append(f"{operators_mapping['>=']}{gcd}")
        return result+[c for c in conditions if operators_mapping['eq'] in c]
    
    def save_dot(self, filename: str, fmt=None,  visual=False, background_data:pd.DataFrame=None, 
                instance2explain=None, counterfactual=None) -> None:
        f = open(filename, "w")
        if visual:
            if background_data is not None:
                if instance2explain is not None and not isinstance(instance2explain, pd.DataFrame):
                    instance2explain=pd.DataFrame(instance2explain)
                if counterfactual is not None and not isinstance(counterfactual, pd.DataFrame):
                    counterfactual=pd.DataFrame(counterfactual)
            f.write(self.to_dot_visual(parent=None, fmt=fmt, background_data=background_data,
                                      instance2explain=instance2explain, counterfactual=counterfactual))
        else:
            f.write(self.to_dot(parent=None,fmt=fmt))
        f.close()

    def get_class_attribute(self) -> Attribute:
        temp  = self.root
        while not temp.is_leaf():
            temp = temp.get_edges()[0].get_child()

        result = {'name': temp.get_att(), 'domain': set(), 'type': None, 'value_to_split_on': '', 'info_gain': 0.0}
        for v in temp.get_stats().get_statistics():
            result['domain'].add(v['name'])

        return result

    def fill_rules(self, rules: list, current_rule: list, root: TreeNode) -> list:
        if not current_rule:
            current_rule = []

        att_name = root.get_att()
        if not root.is_leaf():
            for e in root.get_edges():
                new_rule = current_rule.copy()
                new_rule.append(self.Condition(att_name, e.get_value(), "eq"))
                self.fill_rules(rules, new_rule, e.get_child())

        else:
            final_rule = current_rule.copy()
            final_rule.append(self.Condition(att_name, root.get_stats().get_most_probable(), "set"))
            rules.append(final_rule)

        return rules

    def get_rules(self) -> list:
        return self.fill_rules([], None, self.get_root())

    def fill_attributes(self, result=None, root=None) -> list:
         if result != None and root != None:
            att_name = root.get_att()
            att = {'name': att_name, 'domain': set(), 'type': root.get_type(), 'value_to_split_on': '', 'info_gain': 0.0}
            att['info_gain'] = root.get_infogain()
            for val in result:
                if val['name'] == att['name']:
                    for tmp in result:
                        if tmp == att['name']:
                            att = tmp
                            break
                    break

            if not root.is_leaf():
                for  e in root.get_edges():
                    att['domain'].add(e.get_value()['name'])
                    self.fill_attributes(result, e.get_child())
                should_add = True
                for val in result:
                    if val['name'] == att['name']:
                        should_add = False
                if should_add:
                    result.append(att)
            else:
                for v in root.get_stats().get_statistics():
                    att['domain'].add(v['name'])

                should_add = True
                for val in result:
                    if val['name'] == att['name']:
                        should_add = False
                if should_add:
                    result.append(att)

            return result
         else:

            return self.fill_attributes(list(), root)

    def to_dot(self, parent=None, fmt=None) -> str:
        if parent:
            result = ""
            label = parent.get_att() + "\n"
            if parent.is_leaf():
                # Add classification info to leaves
                for v in parent.get_stats().get_statistics():
                    label += f"{v['name']}[{v['confidence']:{fmt}}]" + "\n"

            col = "red" if parent.is_leaf() else "black"
            result += f"{hash(parent)}[label=\" {label} \",shape=box, color={col}]"

            for te in parent.get_edges():
                if parent.get_type() == Attribute.TYPE_NUMERICAL and fmt is not None:
                    value = te.get_value()['name']
                    value=self.__format_expression(value,fmt)
                else:
                    value = value=te.get_value()['name']
                result += f"{hash(parent)}->{hash(te.get_child())}[label=\"{value}\n conf={round(te.get_value()['confidence'] * 100.0) / 100.0} \"]\n"
                result += self.to_dot(te.get_child(),fmt=fmt)

            return result

        else:
            result = "digraph mediationTree{\n"
            result += self.to_dot(self.root,fmt=fmt)

            return result+"\n}"
        
    @staticmethod    
    def __find_features(background_data, expr):
        features = sorted(background_data.columns,key=len,reverse=True)
        columns=[]
        for f in features:
            if f in expr:
                expr = expr.replace(f, "")
                columns+=[f]
        return columns
    
    def __format_expression(self,value,fmt):
        value_tr = value
        for f in [a['name'] for a in self.get_attributes()]:
            value_tr = re.sub(r'\b[a-zA-Z_]\w*\b','',value_tr)
        numbers = re.findall("[-]?[.]?[\d]+(?:,\d\d\d)*[\.]?\d*(?:[eE][-+]?\d+)?", value_tr)
        formatted = [("{value:"+fmt+"}").format(value=float(v)) for v in numbers]
        for k,v in zip(numbers, formatted):
            value = value.replace(k,v)
        return value

    def to_dot_visual(self, parent=None, background_data: pd.DataFrame=None, instance2explain=None, counterfactual=None, file_format='png', palette='Set2', fmt=None) -> str:
        path = '.'
        features=[]
        target_column = background_data.columns[-1]
        background_data[target_column] = background_data[target_column].astype(str)
        pattern = r'\b[A-Za-z]+(?:[^a-zA-Z\s0-9]+[A-Za-z]+)*(?:\s[A-Za-z]+(?:[^a-zA-Z\s0-9]+[A-Za-z]+)*)*\b'
        if not os.path.exists(path+'/imgs/'):
            os.makedirs(path+'/imgs/')
        if parent:
            result = ""
            col = "red" if parent.is_leaf() else "black"
            if parent.is_leaf():
                fig,ax=plt.subplots(figsize=(3,3))
                if instance2explain is not None:
                    instance2explain[target_column] = instance2explain[target_column].astype(str)
                    background_data = pd.concat((instance2explain,background_data))
                if counterfactual is not None:
                    counterfactual[target_column] = counterfactual[target_column].astype(str)
                    background_data = pd.concat((counterfactual,background_data))
                background_data[target_column] = background_data[target_column].astype(str)
                stats = background_data[[target_column]].value_counts().to_frame('samples').sort_index().reset_index()
                if len(stats) > 0:
                    sns.barplot(data = stats,
                            x=target_column,y='samples', alpha=0.7,palette=palette,hue=target_column,ax=ax)
                else:
                    sns.heatmap(pd.DataFrame([0]), cbar=False, ax=ax)
                    ax.set_facecolor('gray')
                    plt.text(0.5, 0.5, 'Phantom', ha='center', va='center', fontsize=20, color='white', weight='bold')

                if instance2explain is not None:
                    pos = stats[stats[target_column]==instance2explain[target_column].values[0]].index[0]
                    ax.plot(pos,1, 'or', markersize=8)
                if counterfactual is not None:
                    pos = stats[stats[target_column]==counterfactual[target_column].values[0]].index[0]
                    ax.plot(pos,1, 'ob', markersize=8)

                if len(stats) > 0:
                    for patch, label in zip(ax.patches, [f'{l:.2f}%' for l in list(
                            background_data[[target_column]].value_counts(normalize=True).sort_index() * 100)]):
                        ax.annotate(label,
                                    (patch.get_x() + patch.get_width() / 2., patch.get_height() / 2),
                                    ha='center', va='center')
                plt.savefig(f'{path}/imgs/{hash(parent)}.{file_format}', format=file_format,bbox_inches='tight')
                plt.close()
                result += f"{hash(parent)}[label=\"\",shape=box, color={col},image=\"{path}/imgs/{hash(parent)}.{file_format}\"]"

            has_plotted=False
            for te in parent.get_edges():
                if parent.get_type() == Attribute.TYPE_NUMERICAL:
                    op=''
                else:
                    op='=='
                
                all_names = set(re.findall(pattern, te.get_value()['name'].replace("and", "")))
                v = te.get_value()['name']
                for name in all_names:
                    new = '`' + name + '`'
                    v = v.replace(name, new)

                sibling_data = background_data.query(f"`{parent.get_att()}`" + f'{op}' + v)
                                                     
                if not has_plotted and not parent.is_leaf():
                    result += f"{hash(parent)}[label=\"\",shape=box, color={col}, image=\"{path}/imgs/{hash(parent)}.{file_format}\"]"
                    has_plotted = True
                    if re.search(r'\b[a-zA-Z_]\w*\b',te.get_value()['name']):
                        #it's and expression, and we need to visualize it as a plot of two features
                        plt.figure(figsize=(8,3))
                        features = Tree.__find_features(background_data,te.get_value()['name'])
                        grid=sns.scatterplot(data = background_data[features+[parent.get_att(),target_column]], x=features[0],y=parent.get_att(),
                                        hue=target_column,palette=palette,alpha=0.5)
                        if instance2explain is not None:
                            ax = grid.axes
                            ax.plot(instance2explain[features[0]],instance2explain[parent.get_att()], 'or', markersize=8)
                        if counterfactual is not None:
                            ax = grid.axes
                            ax.plot(counterfactual[features[0]],counterfactual[parent.get_att()], 'ob', markersize=8)
                        grid.axes.set_title(f"{parent.get_att()}",fontsize=20)
                        data = background_data.eval(re.sub("[<>=]","", v)).to_frame(parent.get_att())
                        data[features[0]] = background_data[features[0]]
                        sns.lineplot(data=data,x=features[0],y=parent.get_att(), linestyle='--',color='r')
                        plt.savefig(f'{path}/imgs/{hash(parent)}.{file_format}', format=file_format,bbox_inches='tight')
                        plt.close()
                    else:
                        grid=sns.displot(background_data, x=parent.get_att(),hue=target_column,kind='hist',fill=True,height=3,
                                         palette=palette,aspect=3,alpha=0.5)
                        ax = grid.axes[0][0]
                        ax.set_title(f"{parent.get_att()}",fontsize=20)
                        ax.axvline(float(re.sub("[<>=]","",te.get_value()['name'])),linestyle='--',color='r')
                        if instance2explain is not None:
                            ax.plot(instance2explain[parent.get_att()],1, 'or', markersize=8)
                        if counterfactual is not None:
                            ax.plot(counterfactual[parent.get_att()],1, 'ob', markersize=8)
                        plt.savefig(f'{path}/imgs/{hash(parent)}.{file_format}', format=file_format,bbox_inches='tight')
                        plt.close()
                if parent.get_type() == Attribute.TYPE_NUMERICAL and fmt is not None:
                    value = te.get_value()['name']
                    value=self.__format_expression(value,fmt)
                else:
                    value = te.get_value()['name']
                    
                result += f"{hash(parent)}->{hash(te.get_child())}[label=\"{value}\n conf={round(te.get_value()['confidence'] * 100.0) / 100.0} \"]\n"
                sibling_instance2explain=instance2explain
                sibling_counterfactual=counterfactual
                if instance2explain is not None:
                    if len(instance2explain.query(f"`{parent.get_att()}`"+f'{op}'+v)) == 0:
                        sibling_instance2explain=None 
                if counterfactual is not None:
                    if len(counterfactual.query(f"`{parent.get_att()}`"+f'{op}'+v)) == 0:
                        sibling_counterfactual=None 
                result += self.to_dot_visual(parent=te.get_child(),background_data=sibling_data,
                                            instance2explain=sibling_instance2explain, 
                                            counterfactual=sibling_counterfactual,palette=palette,fmt=fmt)

            return result

        else:

            palette = dict(zip(background_data[target_column].unique(),sns.color_palette(palette,background_data[target_column].nunique())))

            result = "digraph mediationTree{\n"
            result += self.to_dot_visual(parent=self.root, background_data=background_data,instance2explain=instance2explain, counterfactual=counterfactual, palette=palette,fmt=fmt)

            return result+"\n}"


    def __str__(self, lvl=None, val=None, node=None):
        if lvl != None and val and node:
            result = "|"
            res = "-------" * lvl
            result = result + res
            result += f"is  {val}"
            if node.is_leaf():
                result += f" then {node.get_att()} = {node.get_stats()} \n"
            else:
                result += f"then if {node.get_att()} (play= {node.get_stats()} )\n"
            lvl += 1
            for te in node.get_edges():
                result += self.__str__(lvl, te.get_value(),te.get_child())
        else:
            result = f"if {self.root.get_att()} (play= {self.root.get_stats()})\n"
            for te in self.root.get_edges():
                result += self.__str__(0, te.get_value(), te.get_child())

        return result



    class Condition:
        def __init__(self, att_name: str, value: Dict, op='eq'):
            self.att_name = att_name
            self.value = value
            self.op = op