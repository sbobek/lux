# AUTOGENERATED! DO NOT EDIT! File to edit: src/att_stats.ipynb (unless otherwise specified).

__all__ = ['AttStats']

# Cell
from typing import List,Dict
import pandas as pd
import numpy as np
import warnings

from .attribute import Attribute
# from pyuid3.data import Data   # may cause problems

# Cell
class AttStats:
    def __init__(self, statistics: Dict[str,Dict], avg_confidence: float, avg_abs_importance: float, total_samples: int,  att_type: int):
        self.statistics = statistics
        self.avg_confidence = avg_confidence
        self.avg_abs_importance = avg_abs_importance
        self.att_type = att_type
        self.total_samples = total_samples

    @staticmethod
    def calculate_statistics(att: Dict, data) -> 'AttStats':
        conf_sum = {}
        avg_conf = 0
        avg_abs_importance = 0

        instances = data.instances #no_need2copy

        if instances is None or len(instances) == 0:
            return AttStats(conf_sum, avg_conf, avg_abs_importance,0, att['type'])
        
        att_name=att['name']
        for instance in instances:
            r = instance['readings'][att_name]
            values = r['values']
            for v in values:
                valname = v['name']
                old = conf_sum.get(valname,None)
                if old is not None: 
                    conf_sum[valname] += v['confidence']
                else:
                    conf_sum[valname] = v['confidence']
            
            avg_conf += r['most_probable']['confidence']
            avg_abs_importance += sum(abs(iv) for iv in r['most_probable']['importances'].values())

        size = len(data)
        avg_conf /= size
        avg_abs_importance /= size
        stats = {}
        for stat_k,stat_v in conf_sum.items():
            #Walkaround to deal with numerical values that can have decimal places, e.g.to make sure  3 == 3.0
            if att['type'] == Attribute.TYPE_NUMERICAL:
                stat_k = str(float(stat_k))
            stats[stat_k]=({'name': stat_k, 'confidence': stat_v/size, 'importances': {'Value':1}})

        return AttStats(stats, avg_conf, avg_abs_importance=avg_abs_importance, total_samples=size, att_type=att['type'])

    def get_statistics(self) -> List[Dict]: 
        return list(self.statistics.values())

    def get_avg_confidence(self) -> float:
        return self.avg_confidence

    def get_avg_abs_importance(self) -> float:
        return self.avg_abs_importance

    
    def get_stat_for_value(self, value_name: str) -> float:
        #Walkaround in case of numerical values having decimal places, e.g.to make sure  3 == 3.0
        if self.att_type == Attribute.TYPE_NUMERICAL:
            warnings.warn("Warning: calculating confidence for contibues value. Consider using get_total_stat_for_lt_value or get_total_stat_for_gte_value")
            value_name = str(float(value_name))
        if value_name in self.statistics.keys():
            return self.statistics[value_name]['confidence']
        else:
            return 0
        
    def get_stat_for_lt_value(self, value_name: str) -> float:        
        return np.sum([c['confidence'] for v,c in self.statistics.items() if float(value_name) > float(v)])/self.total_samples
    
    def get_stat_for_gte_value(self, value_name: str) -> float:        
        return np.sum([c['confidence'] for v,c in self.statistics.items() if float(value_name) <= float(v)])/self.total_samples
        

    def get_most_probable(self) -> Dict:
        statistics = list(self.statistics.values())
        confidence = [value['confidence'] for value in statistics]
        highest_conf = max(confidence)
        index = confidence.index(highest_conf)
        return statistics[index]
   

    def __str__(self) -> str:
        result = '{'
        for value in self.statistics.values():
            result += str(value) + ','
        result = result[:-1]  # delete the last coma ','
        result += '}'
        return result
    
    def copy(self) -> 'AttStats':
        return type(self)(statistics=self.statistics.copy(), avg_confidence=self.avg_confidence ,avg_abs_importance=self.avg_abs_importance,att_type=self.att_type , total_samples=self.total_samples)
